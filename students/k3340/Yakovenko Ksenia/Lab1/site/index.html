<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <meta name="generator" content="mkdocs-1.6.1, mkdocs-terminal-4.7.0">
     
     
    <link rel="icon" type="image/png" sizes="192x192" href="img/android-chrome-192x192.png" />
<link rel="icon" type="image/png" sizes="512x512" href="img/android-chrome-512x512.png" />
<link rel="apple-touch-icon" sizes="180x180" href="img/apple-touch-icon.png" />
<link rel="shortcut icon" type="image/png" sizes="48x48" href="img/favicon.ico" />
<link rel="icon" type="image/png" sizes="16x16" href="img/favicon-16x16.png" />
<link rel="icon" type="image/png" sizes="32x32" href="img/favicon-32x32.png" />


    
 
<title>Лабораторная работа №1: Работа с сокетами - Lab 1</title>


<link href="css/fontawesome/css/fontawesome.min.css" rel="stylesheet">
<link href="css/fontawesome/css/solid.min.css" rel="stylesheet">
<link href="css/normalize.css" rel="stylesheet">
<link href="css/terminal.css" rel="stylesheet">
<link href="css/theme.css" rel="stylesheet">
<link href="css/theme.tile_grid.css" rel="stylesheet">
<link href="css/theme.footer.css" rel="stylesheet">
<!-- default color palette -->
<link href="css/palettes/default.css" rel="stylesheet">

<!-- page layout -->
<style>
/* initially set page layout to a one column grid */
.terminal-mkdocs-main-grid {
    display: grid;
    grid-column-gap: 1.4em;
    grid-template-columns: auto;
    grid-template-rows: auto;
}

/*  
*   when side navigation is not hidden, use a two column grid.  
*   if the screen is too narrow, fall back to the initial one column grid layout.
*   in this case the main content will be placed under the navigation panel. 
*/
@media only screen and (min-width: 70em) {
    .terminal-mkdocs-main-grid {
        grid-template-columns: 4fr 9fr;
    }
}</style>



     
    
    

    
    <!-- search css support -->
<link href="css/search/bootstrap-modal.css" rel="stylesheet">
<!-- search scripts -->
<script>
    var base_url = ".",
    shortcuts = "{}";
</script>
<script src="js/jquery/jquery-1.10.1.min.js" defer></script>
<script src="js/bootstrap/bootstrap.min.js" defer></script>
<script src="js/mkdocs/base.js" defer></script>
    
    
    
    
    <script src="search/main.js"></script>
    

    
</head>

<body class="terminal"><div class="container">
    <div class="terminal-nav">
        <header class="terminal-logo">
            <div id="mkdocs-terminal-site-name" class="logo terminal-prompt"><a href="/" class="no-style">Lab 1</a></div>
        </header>
        
        <nav class="terminal-menu">
            
        </nav>
    </div>
</div>
        
    <div class="container">
        <div class="terminal-mkdocs-main-grid"><aside id="terminal-mkdocs-side-panel"><nav>
  
</nav><hr>
<nav>
    <ul>
        <li><a href="#no1">Лабораторная работа №1: Работа с сокетами</a></li>
        <li><a href="#_1">Цель работы</a></li><li><a href="#1-udp">Задание 1: UDP</a></li><li><a href="#2-tcp">Задание 2: TCP</a></li><li><a href="#3-http">Задание 3: HTTP</a></li><li><a href="#4">Задание 4: Чат</a></li><li><a href="#5-">Задание 5: Мини веб-сервер</a></li><li><a href="#_10">Выводы</a></li>
    </ul>
</nav>
</aside>
            <main id="terminal-mkdocs-main-content">
<section id="mkdocs-terminal-content">
    <h1 id="no1">Лабораторная работа №1: Работа с сокетами</h1>
<h2 id="_1">Цель работы</h2>
<p>Научиться работать с сетевыми сокетами (UDP, TCP, HTTP) и реализовать клиент-серверные программы.</p>
<h2 id="1-udp">Задание 1: UDP</h2>
<p>Сокет<br />
: Программный интерфейс для сетевого обмена данными.<br />
: Представляет конечную точку связи — сочетание IP-адреса, порта и протокола (TCP или UDP).<br />
: Через сокеты процессы на разных компьютерах (или на одном) могут отправлять и принимать данные.<br />
: В Python создаётся функцией <code>socket.socket()</code>.  </p>
<p>UDP (User Datagram Protocol)<br />
: Транспортный протокол без установления соединения.<br />
: Быстрее, чем TCP, но не гарантирует доставку сообщений и их порядок.<br />
: Использует датаграммы — отдельные пакеты, каждый передаётся самостоятельно.<br />
: В Python клиент отправляет данные с помощью <code>sendto()</code>, а сервер получает через <code>recvfrom()</code>.<br />
: Подходит для простых обменов, где потеря некоторых пакетов некритична (например, видео, аудио или учебные примеры).</p>
<p>В этом задании я реализовала клиентскую и серверную часть приложения, используя протокол UDP и библиотеку socket:</p>
<h3 id="_2">Код серверной части:</h3>
<pre><code>import socket

HOST = &quot;127.0.0.1&quot;   # local adr
PORT = 30114         # port

sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
sock.bind((HOST, PORT))

print(f&quot;UDP server is launched on {HOST}:{PORT}&quot;)

while True:
    data, addr = sock.recvfrom(1996)
    print(f&quot;Received from {addr}: {data.decode()}&quot;)

    if data:
        response = &quot;Hello, client&quot;
        sock.sendto(response.encode(), addr)  # answer sending
</code></pre>
<ol>
<li>Создаётся UDP-сокет с параметрами <code>AF_INET</code> (IPv4) и <code>SOCK_DGRAM</code> (UDP).  </li>
<li>Сокет привязывается к адресу <code>127.0.0.1</code> и порту <code>30114</code> с помощью <code>bind()</code>.  </li>
<li>В бесконечном цикле сервер:</li>
<li>получает сообщение от клиента функцией <code>recvfrom()</code>,  </li>
<li>выводит полученные данные в консоль,  </li>
<li>формирует строку ответа <code>"Hello, client"</code> и отправляет её клиенту через <code>sendto()</code>.  </li>
</ol>
<p>Так сервер постоянно ждёт входящих сообщений и на каждое отвечает фиксированной строкой.</p>
<h3 id="_3">Код клиентского приложения:</h3>
<pre><code>import socket

SERVER_HOST = &quot;127.0.0.1&quot;
SERVER_PORT = 30114

sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

message = &quot;Hello, server&quot;
sock.sendto(message.encode(), (SERVER_HOST, SERVER_PORT))
print(f&quot;Sent to the server: {message}&quot;)

data, addr = sock.recvfrom(1996)
print(f&quot;The answer from server{data.decode()}&quot;)

sock.close()
</code></pre>
<ol>
<li>Создаётся UDP-сокет.  </li>
<li>Клиент формирует строку <code>"Hello, server"</code> и отправляет её на сервер функцией <code>sendto()</code>.  </li>
<li>Получает ответ от сервера функцией <code>recvfrom()</code>.  </li>
<li>Выводит полученные данные в консоль и закрывает соединение с помощью <code>close()</code>.  </li>
</ol>
<p><img alt="hello, client" src="images/screenshots/hello%20server.png" /></p>
<h2 id="2-tcp">Задание 2: TCP</h2>
<p>TCP (Transmission Control Protocol)<br />
: Транспортный протокол с установлением соединения.<br />
: Обеспечивает надёжную передачу данных: гарантирует доставку и порядок байтов.<br />
: Работает как поток — границ сообщений нет, приложение само должно решать, где заканчивается одно сообщение и начинается другое.<br />
: Подходит там, где важна точность (например, веб-страницы, файлы, базы данных).  </p>
<p>Сокет в TCP<br />
: Сервер создаёт сокет, привязывает его к адресу (<code>bind()</code>), переводит в режим ожидания (<code>listen()</code>) и ждёт клиентов (<code>accept()</code>).<br />
: <code>accept()</code> блокируется до подключения клиента и возвращает <strong>новый сокет</strong> для общения только с ним.<br />
: Клиент создаёт сокет и подключается к серверу через <code>connect()</code>.<br />
: Обмен данными выполняется с помощью <code>sendall()</code> (отправка) и <code>recv()</code> (получение).  </p>
<p>Различие TCP и UDP<br />
: TCP устанавливает соединение, надёжный и потоковый, но работает медленнее.<br />
: UDP — без соединения, быстрее, но не гарантирует доставку и порядок сообщений.  </p>
<h3 id="_4">Код серверного приложения</h3>
<pre><code>import socket

HOST = &quot;127.0.0.1&quot;
PORT = 30114

# TCP-server socket
server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server_socket.bind((HOST, PORT))
server_socket.listen(1)

print(f&quot;TCP server is launched on {HOST}:{PORT}, waiting for connection...&quot;)

while True:
    conn, addr = server_socket.accept()
    print(f&quot;Client is connected: {addr}&quot;)

    data = conn.recv(1996).decode()
    print(f&quot;Received: {data}&quot;)

    try:
        a, b, h = map(float, data.split())
        result = (a + b) / 2 * h
        response = f&quot;Trapezoid square: {result}&quot;
    except Exception as e:
        response = f&quot;Error: {e}&quot;

    conn.sendall(response.encode())
    conn.close()
</code></pre>
<ol>
<li>Создаётся TCP-сокет.</li>
<li>Сокет привязывается к IP-адресу и порту.</li>
<li>Переводится в режим ожидания подключений (listen()).</li>
<li>В цикле ожидается клиентское подключение (accept()):  <blockquote>
<p>при подключении принимаются данные от клиента;<br />
выполняется вычисление площади по полученным параметрам;<br />
результат передаётся клиенту.  </p>
</blockquote>
</li>
<li>Соединение закрывается, после чего сервер продолжает ожидание новых подключений.</li>
</ol>
<h3 id="_5">Код клиентского приложения:</h3>
<pre><code>import socket

HOST = &quot;127.0.0.1&quot;
PORT = 30114

client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
client_socket.connect((HOST, PORT))

a = input(&quot;Enter base a: &quot;)
b = input(&quot;Enter base b: &quot;)
h = input(&quot;Enter height h: &quot;)

message = f&quot;{a} {b} {h}&quot;
client_socket.sendall(message.encode())

data = client_socket.recv(1996).decode()
print(&quot;Answer from server:&quot;, data)

client_socket.close()

</code></pre>
<ol>
<li>Создаётся TCP-сокет.</li>
<li>Происхходит подключение к серверу по адресу 127.0.0.1 и порту 30114.</li>
<li>Запрос у пользователя: основание a, основание b и высота h.</li>
<li>Формирование строки с этими значениями и отправка серверу через sendall().</li>
<li>Получение от сервера строки-ответа (с вычисленной площадью трапеции) с помощью recv().</li>
<li>Вывод результата в консоль.</li>
<li>Закрытие соединения вызовом close().</li>
</ol>
<p>Таким образом клиент собирает исходные данные от пользователя, передаёт их серверу и получает обратно вычисленный результат.</p>
<p><img alt="" src="images/screenshots/square.png" /></p>
<h2 id="3-http">Задание 3: HTTP</h2>
<p>HTTP (HyperText Transfer Protocol)<br />
: Представляет собой прикладной протокол, используемый для передачи гипертекста (обычно HTML-страниц).<br />
: Работает поверх TCP.<br />
: Клиентом, как правило, выступает браузер, который формирует запросы.<br />
: Сервер принимает запрос, формирует и возвращает ответ.  </p>
<p>Структура HTTP-запроса<br />
: Включает стартовую строку (например, <code>GET / HTTP/1.1</code>), набор заголовков (например, <code>Host</code>, <code>User-Agent</code>), пустую строку и (для POST-запросов) тело.  </p>
<p>Структура HTTP-ответа<br />
: Состоит из статусной строки (например, <code>HTTP/1.1 200 OK</code>), заголовков (<code>Content-Type</code>, <code>Content-Length</code>), пустой строки и тела ответа (HTML-кода).  </p>
<p>Особенности реализации HTTP-сервера<br />
: Запрос читается через <code>recv()</code>, после чего формируется минимальный HTTP-ответ.<br />
: В заголовках обязательно указывается <code>Content-Type</code>, чтобы браузер корректно отобразил страницу.<br />
: В качестве тела ответа используется содержимое HTML-файла или заранее заданная строка.</p>
<h3 id="_6">Код серверного приложения</h3>
<pre><code>import socket

HOST = &quot;127.0.0.1&quot;
PORT = 1996

server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server_socket.bind((HOST, PORT))
server_socket.listen(1)

print(f&quot;HTTP is running on http://{HOST}:{PORT}&quot;)

while True:
    conn, addr = server_socket.accept()
    print(&quot;Connected:&quot;, addr)

    request = conn.recv(1024).decode()
    print(&quot;=== HTTP Request ===&quot;)
    print(request)

    # Загрузка HTML из файла
    try:
        with open(&quot;index.html&quot;, &quot;r&quot;, encoding=&quot;utf-8&quot;) as f:
            body = f.read()
    except FileNotFoundError:
        body = &quot;&lt;html&gt;&lt;body&gt;&lt;h1&gt;File index.html is not found&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&quot;

    # Формирование HTTP-ответа
    response = (
        &quot;HTTP/1.1 200 OK\r\n&quot;
        &quot;Content-Type: text/html; charset=utf-8\r\n&quot;
        f&quot;Content-Length: {len(body.encode())}\r\n&quot;
        &quot;\r\n&quot;
        f&quot;{body}&quot;
    )

    conn.sendall(response.encode())
    conn.close()

</code></pre>
<ol>
<li>Создаётся TCP-сокет с параметрами <code>AF_INET</code> и <code>SOCK_STREAM</code>.  </li>
<li>Сокет привязывается к адресу <code>127.0.0.1</code> и порту <code>1996</code>.  </li>
<li>Переводится в режим ожидания подключений с помощью метода <code>listen()</code>.  </li>
<li>В бесконечном цикле выполняются следующие действия:  <blockquote>
<p>Ожидается подключение клиента (<code>accept()</code>), создаётся новый сокет для взаимодействия.<br />
От клиента принимается HTTP-запрос функцией <code>recv()</code>, содержимое запроса выводится в консоль.<br />
Осуществляется попытка загрузки HTML-страницы из файла <code>index.html</code>.<br />
Если файл отсутствует, в качестве тела ответа используется HTML-заглушка.<br />
Формируется корректный HTTP-ответ, включающий статусную строку, заголовки (<code>Content-Type</code>, <code>Content-Length</code>) и тело с HTML-кодом.<br />
Ответ передаётся клиенту методом <code>sendall()</code>.<br />
Соединение с данным клиентом закрывается.</p>
</blockquote>
</li>
</ol>
<p>В качестве клиента используется <strong>веб-браузер</strong>: при обращении к адресу <code>http://127.0.0.1:1996</code> он формирует HTTP-запрос и отображает полученный от сервера HTML-ответ.</p>
<p><img alt="" src="images/screenshots/glad%20to%20see%20you.png" /></p>
<h2 id="4">Задание 4: Чат</h2>
<p>Чат на основе сокетов<br />
: Реализуется по принципу "один сервер — несколько клиентов".<br />
: Сервер принимает подключения от пользователей и обеспечивает пересылку сообщений между ними.<br />
: Для каждого клиента создаётся отдельный поток или процесс, который обрабатывает его сообщения.<br />
: Все полученные от клиента сообщения пересылаются (рассылаются) остальным участникам чата.  </p>
<p>Особенности реализации<br />
: Сервер хранит список активных клиентов.<br />
: При поступлении сообщения от одного клиента оно передаётся всем остальным с помощью функции-ретранслятора (broadcast).<br />
: При отключении клиента он удаляется из списка активных подключений.<br />
: Для одновременной работы с несколькими клиентами используется многопоточность (модуль <code>threading</code>) или асинхронное программирование.</p>
<h3 id="_7">Код серверного приложения</h3>
<pre><code>import socket
import threading

HOST = &quot;127.0.0.1&quot;
PORT = 30114

clients = []

def handle_client(conn, addr):
    print(f&quot;Connected {addr}&quot;)
    while True:
        try:
            msg = conn.recv(1996).decode()
            if not msg:
                break
            print(f&quot;{addr}: {msg}&quot;)
            broadcast(msg, conn)
        except:
            break
    conn.close()
    clients.remove(conn)
    print(f&quot;{addr} disconnected&quot;)

def broadcast(message, sender_conn):
    for client in clients:
        if client != sender_conn:
            client.sendall(message.encode())

server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server_socket.bind((HOST, PORT))
server_socket.listen()
print(f&quot;Chat-server is running on {HOST}:{PORT}&quot;)

while True:
    conn, addr = server_socket.accept()
    clients.append(conn)
    thread = threading.Thread(target=handle_client, args=(conn, addr))
    thread.start()
</code></pre>
<ol>
<li>Создаётся TCP-сокет.  </li>
<li>Сокет привязывается к IP-адресу и порту.  </li>
<li>Переводится в режим ожидания подключений (<code>listen()</code>).  </li>
<li>В бесконечном цикле:  <blockquote>
<p>ожидается подключение нового клиента (<code>accept()</code>);<br />
создаётся отдельный поток для обработки сообщений данного клиента;<br />
поток принимает входящие сообщения и вызывает функцию <code>broadcast</code> для рассылки текста всем остальным клиентам;<br />
при отключении клиента соединение закрывается, а он удаляется из списка активных подключений.  </p>
</blockquote>
</li>
</ol>
<h3 id="_8">Код клиентского приложения</h3>
<pre><code>import socket
import threading

HOST = &quot;127.0.0.1&quot;
PORT = 30114

def receive(sock):
    while True:
        try:
            msg = sock.recv(1996).decode()
            if msg:
                print(&quot;\nMessage:&quot;, msg)
        except:
            break

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect((HOST, PORT))

# stream for getting messages
thread = threading.Thread(target=receive, args=(sock,))
thread.start()

print(&quot;Connected to the chat! Enter your message:&quot;)

while True:
    msg = input()
    sock.sendall(msg.encode())
</code></pre>
<ol>
<li>Создаётся TCP-сокет.  </li>
<li>Выполняется подключение к серверу (<code>connect()</code>).  </li>
<li>Запускается отдельный поток для получения входящих сообщений и их отображения в консоли.  </li>
<li>В основном цикле клиент вводит сообщения с клавиатуры.  </li>
<li>Каждое введённое сообщение отправляется серверу.  </li>
<li>Соединение может быть закрыто пользователем или при разрыве связи.  </li>
</ol>
<p>Таким образом, чат позволяет нескольким клиентам одновременно обмениваться сообщениями через сервер, который выступает посредником и рассылает их всем участникам.</p>
<p><img alt="Как видят переписку участники чата" src="images/screenshots/clients.png" />
<img alt="Как отображается чат со стороны сервера" src="images/screenshots/server.png" /></p>
<h2 id="5-">Задание 5: Мини веб-сервер</h2>
<p>Веб-сервер с поддержкой GET и POST<br />
: Реализуется на основе TCP-сокета.<br />
: Обрабатывает HTTP-запросы браузера и формирует HTML-страницу с данными.<br />
: Поддерживает два метода:<br />
  - <strong>GET</strong> — используется для запроса страницы и отображения текущих данных.<br />
  - <strong>POST</strong> — применяется для передачи информации от клиента (например, отправки формы).  </p>
<p>Особенности реализации<br />
: При обработке POST-запроса тело сообщения парсится, и данные добавляются к общему списку/словарю.<br />
: HTML-страница формируется динамически: отображаются все накопленные данные и форма для добавления новых.<br />
: Для разбора параметров используется функция <code>urllib.parse.parse_qs</code>.<br />
: Сервер простейший, поэтому данные сохраняются только в оперативной памяти.  </p>
<h3 id="_9">Код серверной части</h3>
<pre><code>import socket
import urllib.parse

HOST = &quot;127.0.0.1&quot;
PORT = 30114

# использую словарь
grades = {}

server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server.bind((HOST, PORT))
server.listen(1)

print(f&quot;Server is running: http://{HOST}:{PORT}&quot;)

def build_page():
    rows = &quot;&quot;
    for subj, marks in grades.items():
        rows += f&quot;&lt;tr&gt;&lt;td&gt;{subj}&lt;/td&gt;&lt;td&gt;{', '.join(marks)}&lt;/td&gt;&lt;/tr&gt;&quot;
    return f&quot;&quot;&quot;
    &lt;html&gt;&lt;body&gt;
        &lt;h1&gt;Marks&lt;/h1&gt;
        &lt;table border=&quot;1&quot; cellpadding=&quot;5&quot;&gt;
            &lt;tr&gt;&lt;th&gt;Subject&lt;/th&gt;&lt;th&gt;Marks&lt;/th&gt;&lt;/tr&gt;
            {rows}
        &lt;/table&gt;
        &lt;form method=&quot;POST&quot;&gt;
            &lt;p&gt;Subject: &lt;input name=&quot;subject&quot;&gt;&lt;/p&gt;
            &lt;p&gt;Mark: &lt;input name=&quot;mark&quot;&gt;&lt;/p&gt;
            &lt;p&gt;&lt;input type=&quot;submit&quot; value=&quot;Add&quot;&gt;&lt;/p&gt;
        &lt;/form&gt;
    &lt;/body&gt;&lt;/html&gt;
    &quot;&quot;&quot;

while True:
    conn, addr = server.accept()
    request = conn.recv(2002).decode()

    headers, _, body = request.partition(&quot;\r\n\r\n&quot;)
    if request.startswith(&quot;POST&quot;):
        params = urllib.parse.parse_qs(body)
        subj = params.get(&quot;subject&quot;, [&quot;&quot;])[0]
        mark = params.get(&quot;mark&quot;, [&quot;&quot;])[0]
        if subj and mark:
            grades.setdefault(subj, []).append(mark)

    page = build_page()
    response = &quot;HTTP/1.1 200 OK\r\nContent-Type: text/html; charset=utf-8\r\n\r\n&quot; + page
    conn.sendall(response.encode())
    conn.close()
</code></pre>
<ol>
<li>Создаётся TCP-сокет и привязывается к адресу <code>127.0.0.1:30114</code>.  </li>
<li>Сервер переводится в режим ожидания подключений.  </li>
<li>В качестве хранилища используется словарь <code>grades</code>, где ключом является предмет, а значением — список оценок.  </li>
<li>На каждом новом подключении принимается HTTP-запрос.  </li>
<li>При использовании метода <code>POST</code> тело запроса разбирается с помощью <code>urllib.parse.parse_qs()</code>, и данные добавляются в словарь.  </li>
<li>HTML-страница формируется функцией <code>build_page()</code> (таблица с текущими оценками и форма для добавления новых).  </li>
<li>Клиенту отправляется HTTP-ответ со статусом <code>200 OK</code>, заголовком <code>Content-Type: text/html; charset=utf-8</code> и телом HTML-страницы.  </li>
<li>Соединение закрывается.</li>
</ol>
<p>Добавление оценок пользователь может производить непосредственно на странице в браузере. Каждое действие пользователя обрабатывается как отдельный HTTP-запрос.  </p>
<ul>
<li>
<p>При открытии страницы в браузере формируется <strong>HTTP GET-запрос</strong>.<br />
  Сервер принимает его, собирает HTML-страницу и отправляет обратно.<br />
  После этого соединение с клиентом закрывается (<code>conn.close()</code>).  </p>
</li>
<li>
<p>При добавлении новой оценки через форму браузер отправляет <strong>HTTP POST-запрос</strong>.<br />
  Сервер принимает данные, обновляет словарь <code>grades</code>, формирует HTML-страницу с обновлёнными значениями и отправляет её клиенту.<br />
  Сразу после отправки ответного сообщения соединение снова закрывается (<code>conn.close()</code>).  </p>
</li>
</ul>
<p>Таким образом, в реализации сервера каждое взаимодействие (просмотр страницы или добавление оценки) обрабатывается в рамках нового соединения.</p>
<p float="left">
  <img src="images/screenshots/marks1.png" alt="Уже добавили немного оценок" width="250" />
  <img src="images/screenshots/marks2.png" alt="Хотим ещё добавить" width="250" />
  <img src="images/screenshots/marks3.png" alt="Добавили" width="250" />
</p>

<h2 id="_10">Выводы</h2>
<p>В ходе выполнения лабораторной работы я реализовала пять заданий, связанных с использованием сокетов в Python.<br />
На практике изучила основные протоколы транспортного уровня (UDP и TCP), а также принципы работы HTTP и взаимодействия клиента и сервера.<br />
Дополнительно был реализован многопользовательский чат и веб-сервер с обработкой GET- и POST-запросов.</p>
<p>До выполнения этой работы опыт написания серверных приложений на Python у меня отсутсвовал.<br />
В процессе выполнения заданий удалось разобраться в базовых функциях модуля <code>socket</code>, освоить структуру HTTP-запросов и ответов.<br />
Кроме того, была получена практика работы с потоками (для чата) и динамическим формированием HTML-страниц (для веб-сервера).</p>
<p>Таким образом, благодаря лабораторной работе были приобретены первоначальные навыки разработки сетевых приложений на Python.</p>
</section>

            </main>
        </div>
        <hr><footer>
    <div class="terminal-mkdocs-footer-grid">
        <div id="terminal-mkdocs-footer-copyright-info">
             Site built with <a href="http://www.mkdocs.org">MkDocs</a> and <a href="https://github.com/ntno/mkdocs-terminal">Terminal for MkDocs</a>.
        </div>
    </div>
</footer>
    </div>

    
    <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="alertdialog" aria-modal="true" aria-labelledby="searchModalLabel">
    <div class="modal-dialog modal-lg" role="search">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="searchModalLabel">Search</h5>
                <button type="button" class="close btn btn-default btn-ghost" data-dismiss="modal"><span aria-hidden="true">x</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
                <p id="searchInputLabel">Type to start searching</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" aria-labelledby="searchInputLabel" placeholder="" id="mkdocs-search-query" title="Please enter search terms here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No document matches found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>
    
    
</body>

</html>